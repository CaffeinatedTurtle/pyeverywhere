#!/usr/bin/env python

import argparse
import glob
import json
import logging
logging.basicConfig()
import os
import plistlib
import shutil
import subprocess
import sys
import tempfile

from distutils.core import setup

import pewtools

try:
    input = raw_input
except NameError:
    pass

thisdir = os.path.dirname(os.path.abspath(__file__))
srcdir = os.path.join(thisdir, 'src')

android_dir = os.path.join(thisdir, "native", "android")

platforms = [
    "android",
    "ios",
    "mac",
    "win"
]


def codesign_mac(path, identity):
    cmd = ["codesign", "--force", "-vvv", "--verbose=4", "--sign", identity]

    cmd.append(path)
    logging.info("running %s" % " ".join(cmd))

    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    proc.wait()
    for line in proc.stdout:
        logging.info(line)
    for line in proc.stderr:
        logging.error(line)

    if proc.returncode != 0:
        logging.error("Code signing failed")
        print("Unable to codesign %s" % path)
        sys.exit(1)
    else:
        logging.info("Code signing succeeded for %s" % path)
        cmd = ['codesign', "--verify", "--deep", "--verbose=4", path]
        logging.info("calling %s" % " ".join(cmd))
        if subprocess.call(cmd) != 0:
            print("Code signed application failed validation.")
            sys.exit(1)


cwd = os.getcwd()

info_json = {}

info_file = os.path.join(cwd, "project_info.json")

def dir_is_pew(check_dir):
    return os.path.exists(os.path.join(cwd, "project_info.json"))

def create(args):
    if args.name:
        safe_name = args.name.replace(" ", "")
        dir_name = os.path.join(cwd, safe_name)
        print("Creating project %s in directory %s" % (args.name, dir_name))
        if os.path.exists(dir_name):
            print("Project already exists! Please delete or rename the existing project folder and try again.")
            sys.exit(1)

        shutil.copytree(os.path.join(thisdir, "src", "template"), dir_name)
        
        project_json_file = os.path.join(dir_name, "project_info.json")
        project_json = json.load(open(project_json_file))
        
        project_json["name"] = args.name
        project_json["identifier"] = "com.yourdomain.%s" % safe_name
        
        json.dump(project_json, open(project_json_file, 'w'))

def test(args):
    cmd = sys.executable + " src/main.py --test"
    if args.no_functional:
        cmd += " --no-functional"
    sys.exit(os.system(cmd))

def run(args):
    if args.platform == "android":
        apk_name = "%s-%s-debug.apk" % (info_json["name"].replace(" ", ""), info_json["version"])
        apk_file = os.path.join(cwd, "dist", "android", apk_name)
        if not os.path.exists(apk_file):
            print("Could not find APK file to run at %s" % apk_file)
            print("Please ensure that you have performed a build and that it succeeded, and try again.")
            sys.exit(1) 
        cmd = "sh \"%s\" \"%s\" \"%s\"" % (os.path.join(android_dir, "run.sh"), apk_file, info_json["identifier"])
        print("running %s" % cmd)
        sys.exit(os.system(cmd))
    elif args.platform == "ios":
        build(args)  # we can't run the app programmatically, so just use build to load the project.
    else:
        os.system(sys.executable + " src/main.py")

def build(args):
    returncode = 0
    if args.platform == "android":
        filename = info_json["name"].replace(" ", "")
        src_dir = os.path.join(cwd, "src")
        build_dir = os.path.join(cwd, "build", "android")

        if os.path.exists(build_dir):
            shutil.rmtree(build_dir)

        parent_dir = os.path.dirname(build_dir)
        if not os.path.exists(parent_dir):
            os.makedirs(parent_dir)

        shutil.copytree(src_dir, build_dir)
        shutil.copy2(os.path.join(cwd, "project_info.json"), build_dir)

        cmd = "sh \"%s\" \"%s\" \"%s\" \"%s\" \"%s\"" % (os.path.join(android_dir, "build.sh"), info_json["identifier"], filename, info_json["version"], build_dir) 
        print "Running %s" % cmd
        returncode = os.system(cmd)
    if args.platform == "ios":
        project_dir = os.path.join(cwd, "native", "ios", "PythonistaProjectTemplate") 
        plist_file = os.path.join(project_dir, "Info.plist")
        if os.path.exists(plist_file):
            plist = plistlib.readPlist(plist_file)
            plist['CFBundleIdentifier'] = info_json["identifier"]
            plist['CFBundleName'] = plist['CFBundleDisplayName'] = info_json["name"]
            plist['CFBundleVersion'] = info_json["version"]
            plist['CFBundleShortVersionString'] = info_json["version"]
            if "icons" in info_json and "ios" in info_json["icons"]:
                icons = info_json["icons"]["ios"]
                if len(icons) > 0:
                    plist['CFBundleIconFiles'] = icons

            plistlib.writePlist(plist, plist_file)

        project_file = os.path.join(project_dir, "Project.xcodeproj")
        os.system("open %s" % project_file.replace(" ", "\\ "))

    elif args.platform in ["mac", "win"]:
        import py2app
        plist = {
            'CFBundleIdentifier': info_json["identifier"],
        }

        sys.argv = [sys.argv[0], "py2app"]

        packages = []

        if "packages" in info_json:
            packages.extend(info_json["packages"])

        dist_dir = "dist/%s" % args.platform
        if not os.path.exists(dist_dir):
            os.makedirs(dist_dir)
        py2app_opts = {
            "dist_dir": dist_dir, 
            'plist': plist,
            "packages": packages,
            "site_packages": True,
        }

        data_files = [('.', [os.path.join(cwd, "project_info.json")])]
        for root, dirs, files in os.walk("src/files"):
            files_in_dir = []
            for afile in files:
                if not afile.startswith("."):
                    files_in_dir.append(os.path.join(root, afile))
            if len(files_in_dir) > 0:
                data_files.append((root.replace("src/", ""), files_in_dir))

        print "data_files = %r" % data_files
        setup(name=info_json["name"],
              version=info_json["version"],
              options={
                  'py2app': py2app_opts,
              },
              app=['src/main.py'],
              data_files=data_files
            )

        if sys.platform.startswith("darwin") and "codesign" in info_json:
            base_path = os.path.join(dist_dir, "%s.app" % info_json["name"])
            print "base_path = %r" % base_path
            # remove the .py files and the .pyo files as we shouldn't use them
            # running a .py file in the bundle can modify it.
            for root, dirs, files in os.walk(os.path.join(base_path, "Contents", "Resources", "lib", "python2.7")):
                for afile in files:
                    fullpath = os.path.join(root, afile)
                    ext = os.path.splitext(fullpath)[1]
                    if ext in ['.py', '.pyo']:
                        os.remove(fullpath)

            sign_paths = []
            sign_paths.extend(glob.glob(os.path.join(base_path, "Contents", "Frameworks", "*.framework")))
            sign_paths.extend(glob.glob(os.path.join(base_path, "Contents", "Frameworks", "*.dylib")))
            exes = ["Python"]
            for exe in exes:
                sign_paths.append(os.path.join(base_path, 'Contents', 'MacOS', exe))
            sign_paths.append(base_path) # the main app needs to be signed last
            for path in sign_paths:
                codesign_mac(path, info_json["codesign"]["osx"]["identity"])

    return returncode

def init(args):
    """
    For now, this is just an alias for update.
    """
    update(args)

def update(args):
    print("Copying latest dependencies into project...")

    tempdir = tempfile.mkdtemp()

    pewtools.get_dependencies_for_platform(args.platform)

    temp_pew = os.path.join(tempdir, 'pew')
    dest_dir = os.path.join(cwd, 'src', 'pew')
    if os.path.exists(dest_dir):
        if input("This will overwrite the existing pew module. Continue? [Y/n]").lower() == "y":
            shutil.move(dest_dir, temp_pew)

    try:
        if not os.path.exists(dest_dir):
            shutil.copytree(os.path.join(srcdir, 'pew'), dest_dir)
    except Exception, e:
        if os.path.exists(temp_pew):
            shutil.move(temp_pew, dest_dir)

    if os.path.exists(tempdir):
        try:
            shutil.rmtree(tempdir)
        except Exception, e:
            import traceback
            logging.error(traceback.format_exc(e))

def main():
    
    parser = argparse.ArgumentParser()
    # parser.add_argument("command", description="", help="Command to run. Acceptable commands are: %r" % commands)
    commands = parser.add_subparsers(title='commands', help='Commands to operate on PyEverywhere projects')

    build_opt = commands.add_parser('build', help="Build PyEverywhere binary")
    build_opt.add_argument('platform', choices=platforms, help='Platform to build project for. Choices are: %r' % (platforms,))
    build_opt.set_defaults(func=build)

    new_opt = commands.add_parser('create', help="Create new PyEverywhere project in the current working directory")
    new_opt.add_argument('name', help='Name of project to create')
    new_opt.set_defaults(func=create)

    up_opt = commands.add_parser('init', help="Initialize the PyEverywhere dependencies for the project in the current working directory.")
    up_opt.add_argument('platform', choices=platforms, help='Platform to run the project on. Choices are: %r' % (platforms,))
    up_opt.set_defaults(func=init)

    run_opt = commands.add_parser('run', help="Run PyEverywhere project")
    run_opt.add_argument('platform', choices=platforms, help='Platform to run the project on. Choices are: %r' % (platforms,))
    run_opt.set_defaults(func=run)

    test_opt = commands.add_parser('test', help="Run PyEverywhere project")
    test_opt.add_argument('platform', choices=platforms, help='Platform to run the project on. Choices are: %r' % (platforms,))
    test_opt.add_argument('--no-functional', action='store_true', help='Only run unit tests, do not start the GUI and run functional tests.')
    test_opt.set_defaults(func=test)

    up_opt = commands.add_parser('update', help="Update the PyEverywhere dependencies for the project in the current working directory.")
    up_opt.add_argument('platform', choices=platforms, help='Platform to run the project on. Choices are: %r' % (platforms,))
    up_opt.set_defaults(func=update)

    args = parser.parse_args()

    if not args.func == create:
        if not os.path.exists(info_file):
            print "Unable to find project info file at %s. pew cannot continue." % info_file
            sys.exit(1)

        global info_json
        info_json = json.loads(open(info_file, "rb").read())
    sys.exit(args.func(args))

if __name__ == "__main__":
    main()
