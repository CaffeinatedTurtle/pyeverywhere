#!/usr/bin/env python

import argparse
import getpass
import glob
import json
import logging
logging.basicConfig()
import os
import plistlib
import shutil
import subprocess
import sys
import tempfile
import webbrowser

from distutils.core import setup

import pewtools

try:
    input = raw_input
except NameError:
    pass

thisdir = os.path.dirname(os.path.abspath(__file__))
srcdir = os.path.join(thisdir, 'src')

config_dir = os.path.expanduser(os.path.join("~", ".pyeverywhere"))
if not os.path.exists(config_dir):
    os.makedirs(config_dir)

config_settings = {
    "android.root": "Path to the directory where the Android tools will be stored"
}

config_file = os.path.join(config_dir, "config.json")
pew_config = {}
if os.path.exists(config_file):
    pew_config = json.load(open(config_file))

android_dir = os.path.join(thisdir, "native", "android")

command_env = os.environ.copy()

android_root = os.path.join(config_dir, "native", "android")
if "android.root" in pew_config:
    android_root = pew_config['android.root']

if not os.path.exists(android_root):
    os.makedirs(android_root)
command_env['ANDROID_ROOT'] = android_root

verbose = False


platforms = [
    "android",
    "browser",
    "ios",
    "linux",
    "mac",
    "win"
]


def run_command(cmd):
    global command_env
    if verbose:
        print("Running command: %r" % cmd)
        print("Environment: %r" % (command_env,))
    return subprocess.call(cmd, env=command_env)


def codesign_mac(path, identity):
    cmd = ["codesign", "--force", "-vvv", "--verbose=4", "--sign", identity]

    cmd.append(path)
    logging.info("running %s" % " ".join(cmd))

    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    proc.wait()
    for line in proc.stdout:
        logging.info(line)
    for line in proc.stderr:
        logging.error(line)

    if proc.returncode != 0:
        logging.error("Code signing failed")
        print("Unable to codesign %s" % path)
        sys.exit(1)
    else:
        logging.info("Code signing succeeded for %s" % path)
        cmd = ['codesign', "--verify", "--deep", "--verbose=4", path]
        logging.info("calling %s" % " ".join(cmd))
        if subprocess.call(cmd) != 0:
            print("Code signed application failed validation.")
            sys.exit(1)


default_key = "default"
cwd = os.getcwd()

info_json = {}

info_file = os.path.join(cwd, "project_info.json")


def copy_files(src_dir, build_dir, ignore_paths):
    def _logpath(path, names):
        for ignore_dir in ignore_paths:
            if ignore_dir in path:
                print("Ignoring %s" % path)
                return names
        print("Copying %s" % path)
        return []
    ignore = _logpath

    if os.path.exists(build_dir):
        shutil.rmtree(build_dir)

    print("Copying source files to build tree, please wait...")
    shutil.copytree(src_dir, build_dir, ignore=ignore)

    pew_src_dir = os.path.join(thisdir, "src", "pew")
    pew_dest_dir = os.path.join(build_dir, "pew")
    # For now, we want to allow developers to use their own customized pew module
    # until we offer more advanced configuration options. If they don't though,
    # just copy ours over.
    if not os.path.exists(pew_dest_dir):
        shutil.copytree(pew_src_dir, pew_dest_dir)

    shutil.copy2(os.path.join(cwd, "project_info.json"), build_dir)


def get_value_for_config(key, config_name, default_return=None):
    if key in info_json:
        if "configs" in info_json[key] and config_name in info_json[key]["configs"]:
            return info_json[key]["configs"][config_name]
        elif default_key in info_json[key]:
            return info_json[key][default_key]

    return default_return


def get_value_for_platform(key, platform_name, default_return=None):
    if key in info_json:
        if platform_name in info_json[key]:
            return info_json[key][platform_name]
        elif default_key in info_json[key]:
            return info_json[key][default_key]

    return default_return


def create_android_setup_sh(info_json):
    global cwd
    android_sdk = "19"
    android_build_tools = "23.0.3"

    if "sdks" in info_json and "android" in info_json["sdks"]:
        android_sdk_info = info_json["sdks"]["android"]
        if "target_sdk" in android_sdk_info:
            android_sdk = str(android_sdk_info["target_sdk"])
        if "build_tools" in android_sdk_info:
            android_build_tools = android_sdk_info["build_tools"]

    android_native_dir = os.path.join(cwd, "native", "android")
    if not os.path.exists(android_native_dir):
        os.makedirs(android_native_dir)

    android_setup_file = os.path.join(android_native_dir, "setup.sh")
    f = open(android_setup_file, "wb")
    f.write("""
export ANDROIDAPI=%s
export ANDROIDBUILDTOOLSVER=%s
""" % (android_sdk, android_build_tools))
    f.close()


def dir_is_pew(check_dir):
    return os.path.exists(os.path.join(cwd, "project_info.json"))


def get(args):
    global config_settings
    if args.name == "all":
        for name in pew_config:
            print("    %s: %s" % (name, pew_config[name]))
    else:
        print("    %s:%s" % (args.name, pew_config[args.name]))


def set(args):
    global pew_config
    name = args.name
    value = args.value
    pew_config[name] = value
    f = open(config_file, "w")
    json.dump(pew_config, f)
    f.close()


def create(args):
    if args.name:
        safe_name = args.name.replace(" ", "")
        dir_name = os.path.join(cwd, safe_name)
        print("Creating project %s in directory %s" % (args.name, dir_name))
        if os.path.exists(dir_name):
            print("Project already exists! Please delete or rename the existing project folder and try again.")
            sys.exit(1)

        shutil.copytree(os.path.join(thisdir, "src", "template"), dir_name)

        project_json_file = os.path.join(dir_name, "project_info.json")
        project_json = json.load(open(project_json_file))

        project_json["name"] = args.name
        project_json["identifier"] = "com.yourdomain.%s" % safe_name

        json.dump(project_json, open(project_json_file, 'w'))


def test(args):
    cmd = sys.executable + " src/main.py --test"
    if args.no_functional:
        cmd += " --no-functional"
    sys.exit(run_command(cmd))


def run(args):
    copy_config_file(args)
    if args.platform == "android":
        apk_name = "%s-%s-debug.apk" % (info_json["name"].replace(" ", ""), info_json["version"])
        apk_file = os.path.join(cwd, "dist", "android", apk_name)
        if not os.path.exists(apk_file):
            print("Could not find APK file to run at %s" % apk_file)
            print("Please ensure that you have performed a build and that it succeeded, and try again.")
            sys.exit(1)
        cmd = ["bash", os.path.join(android_dir, "run.sh"), apk_file, info_json["identifier"]]
        sys.exit(run_command(cmd))
    elif args.platform == "ios":
        build(args)  # we can't run the app programmatically, so just use build to load the project.
    elif args.platform == "browser":
        import pew
        ui_root = "src/files/www/index.html"
        if "ui_root" in info_json:
            ui_root = info_json["ui_root"]

        def open_browser(url):
            webbrowser.open(url)
        pew.start_local_server(os.path.dirname(ui_root), callback=open_browser)
    else:
        run_command([sys.executable, "src/main.py", " ".join(args.args)])


def copy_config_file(args):
    src_dir = os.path.join(cwd, "src")
    local_config = os.path.join(src_dir, "local_config.py")
    if os.path.exists(local_config):
        os.remove(local_config)

    if args.config:
        config_path = os.path.abspath(os.path.join("configs", args.config + ".py"))
        if os.path.exists(config_path):
            shutil.copy2(config_path, os.path.join(src_dir, "local_config.py"))
        else:
            print("Specified config file %s not found. Exiting..." % config_path)
            sys.exit(1)


def build(args):
    returncode = 0
    copy_config_file(args)

    src_dir = os.path.join(cwd, "src")
    build_dir = os.path.join(cwd, "build", args.platform)
    requirements = get_value_for_platform("requirements", args.platform, [])
    requirements = requirements + get_value_for_platform("requirements", "common", [])

    ignore_paths = []
    if args.config != "":
        ignore_dirs = get_value_for_config("ignore_dirs", args.config)
        print("Ignore dirs specified: %r" % ignore_dirs)
        if ignore_dirs:
            for ignore_dir in ignore_dirs:
                ignore_paths.append(os.path.abspath(ignore_dir))

    if args.platform == "android":
        filename = info_json["name"].replace(" ", "")
        if args.config and args.config.strip() != "":
            build_dir = os.path.join(build_dir, args.config)

        icon_dir = os.path.join(cwd, "icons", "android")
        icon = os.path.join(icon_dir, get_value_for_platform("icons", "android", "fakefile"))
        print("Icon is %s" % icon)
        whitelist = os.path.abspath(get_value_for_platform("whitelist_file", "android", "fakefile"))
        launch = os.path.abspath(get_value_for_platform("launch_images", "android", "fakefile"))
        orientation = get_value_for_platform("orientation", "android", "sensor")

        keystore = ""
        keyalias = ""
        keypasswd = ""

        build_type = ""
        if args.release:
            build_type = "release"
            signing = get_value_for_platform("codesign", "android", "")
            keystore = os.path.abspath(signing['keystore'])
            keyalias = signing['alias']
            print("signing = %r" % (signing,))
            print("keystore = %r, alias = %r" % (keystore, keyalias))
            if 'passwd' in signing:
                keypasswd = signing['passwd']
            else:
                keypasswd = getpass.getpass()

        if len(requirements) > 0:
            requirements = ",".join(requirements)
        else:
            requirements = ""

        if os.path.exists(build_dir):
            shutil.rmtree(build_dir)

        parent_dir = os.path.dirname(build_dir)
        if not os.path.exists(parent_dir):
            os.makedirs(parent_dir)

        copy_files(src_dir, build_dir, ignore_paths)

        cmd = ["bash", os.path.join(android_dir, "build.sh"), info_json["identifier"], filename, info_json["version"], build_dir, icon, launch, whitelist, orientation, requirements, build_type, keystore, keyalias, keypasswd]
        returncode = run_command(cmd)
    if args.platform == "ios":
        project_dir = os.path.join(cwd, "native", "ios", "PythonistaAppTemplate")
        if os.path.exists(build_dir):
            shutil.rmtree(build_dir)
        project_build_dir = os.path.join(build_dir, os.path.basename(project_dir))
        shutil.copytree(project_dir, project_build_dir)
        plist_file = os.path.join(build_dir, "PythonistaAppTemplate", "Info.plist")
        if os.path.exists(plist_file):
            version_short = info_json["version"].split(".")
            version_short = ".".join(version_short[:3])
            plist = plistlib.readPlist(plist_file)
            plist['CFBundleIdentifier'] = info_json["identifier"]
            plist['CFBundleName'] = plist['CFBundleDisplayName'] = info_json["name"]
            plist['CFBundleVersion'] = info_json["version"]
            plist['CFBundleShortVersionString'] = version_short
            if "icons" in info_json and "ios" in info_json["icons"]:
                icons = info_json["icons"]["ios"]
                if len(icons) > 0:
                    plist['CFBundleIconFiles'] = icons

            plistlib.writePlist(plist, plist_file)

        files_dir = os.path.join(project_build_dir, "Script")
        copy_files(src_dir, files_dir, ignore_paths)

        project_file = os.path.join(project_build_dir, "PythonistaAppTemplate.xcodeproj")
        config_file = os.path.join(project_file, "project.pbxproj")

        # FIXME: This currently only works for pure-Python modules.
        pewtools.copy_deps_to_build(requirements, build_dir, files_dir)

        if os.path.exists(config_file):
            f = open(config_file, 'rb')
            config = f.read()
            f.close()

            config = config.replace("My App", info_json["name"])
            f = open(config_file, 'wb')
            f.write(config)
            f.close()
        else:
            print("Unable to update XCode project config file. You may need to manually change some settings.")

        run_command(["open", project_file.replace(" ", "\\ ")])

    elif args.platform in ["mac", "win"]:
        import py2app
        plist = {
            'CFBundleIdentifier': info_json["identifier"],
        }

        sys.argv = [sys.argv[0], "py2app"]

        packages = []

        if "packages" in info_json:
            packages.extend(info_json["packages"])

        dist_dir = "dist/%s" % args.platform
        if not os.path.exists(dist_dir):
            os.makedirs(dist_dir)
        py2app_opts = {
            "dist_dir": dist_dir, 
            'plist': plist,
            "packages": packages,
            "site_packages": True,
        }

        data_files = [('.', [os.path.join(cwd, "project_info.json")])]
        for root, dirs, files in os.walk("src/files"):
            files_in_dir = []
            for afile in files:
                if not afile.startswith("."):
                    files_in_dir.append(os.path.join(root, afile))
            if len(files_in_dir) > 0:
                data_files.append((root.replace("src/", ""), files_in_dir))

        print "data_files = %r" % data_files
        setup(name=info_json["name"],
              version=info_json["version"],
              options={
                  'py2app': py2app_opts,
              },
              app=['src/main.py'],
              data_files=data_files
              )

        if sys.platform.startswith("darwin") and "codesign" in info_json:
            base_path = os.path.join(dist_dir, "%s.app" % info_json["name"])
            print "base_path = %r" % base_path
            # remove the .py files and the .pyo files as we shouldn't use them
            # running a .py file in the bundle can modify it.
            for root, dirs, files in os.walk(os.path.join(base_path, "Contents", "Resources", "lib", "python2.7")):
                for afile in files:
                    fullpath = os.path.join(root, afile)
                    ext = os.path.splitext(fullpath)[1]
                    if ext in ['.py', '.pyo']:
                        os.remove(fullpath)

            sign_paths = []
            sign_paths.extend(glob.glob(os.path.join(base_path, "Contents", "Frameworks", "*.framework")))
            sign_paths.extend(glob.glob(os.path.join(base_path, "Contents", "Frameworks", "*.dylib")))
            exes = ["Python"]
            for exe in exes:
                sign_paths.append(os.path.join(base_path, 'Contents', 'MacOS', exe))
            sign_paths.append(base_path)  # the main app needs to be signed last
            for path in sign_paths:
                codesign_mac(path, info_json["codesign"]["osx"]["identity"])

    return returncode


def init(args):
    """
    For now, this is just an alias for update.
    """
    update(args)


def update(args):
    print("Copying latest dependencies into project...")

    tempdir = tempfile.mkdtemp()

    pewtools.get_dependencies_for_platform(args.platform)
    global command_env, verbose
    pewtools.initialize_platform(args.platform, command_env, verbose=verbose)

    temp_pew = os.path.join(tempdir, 'pew')
    dest_dir = os.path.join(cwd, 'src', 'pew')
    if os.path.exists(dest_dir) and args.platform == "pew":
        if input("This will overwrite the existing pew module. Continue? [Y/n]").lower() == "y":
            shutil.move(dest_dir, temp_pew)

    try:
        if not os.path.exists(dest_dir):
            shutil.copytree(os.path.join(srcdir, 'pew'), dest_dir)
    except Exception, e:
        if os.path.exists(temp_pew):
            shutil.move(temp_pew, dest_dir)

    if os.path.exists(tempdir):
        try:
            shutil.rmtree(tempdir)
        except Exception, e:
            import traceback
            logging.error(traceback.format_exc(e))


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", dest="verbose", action="store_true", help="Enable verbose output")
    # parser.add_argument("command", description="", help="Command to run. Acceptable commands are: %r" % commands)
    commands = parser.add_subparsers(title='commands', help='Commands to operate on PyEverywhere projects')

    build_opt = commands.add_parser('build', help="Build PyEverywhere binary")
    build_opt.add_argument('platform', choices=platforms, help='Platform to build project for. Choices are: %r' % (platforms,))
    build_opt.add_argument('--release', action='store_true', help='Build the app in release mode.')
    build_opt.add_argument('--config', default=None, help='Specify a Python config file to use when building the app.')
    build_opt.set_defaults(func=build)

    new_opt = commands.add_parser('create', help="Create new PyEverywhere project in the current working directory")
    new_opt.add_argument('name', help='Name of project to create')
    new_opt.set_defaults(func=create)

    up_opt = commands.add_parser('init', help="Initialize the PyEverywhere dependencies for the project in the current working directory.")
    up_opt.add_argument('platform', choices=platforms, help='Platform to run the project on. Choices are: %r' % (platforms,))
    up_opt.set_defaults(func=init)

    run_opt = commands.add_parser('run', help="Run PyEverywhere project")
    run_opt.add_argument('platform', choices=platforms, help='Platform to run the project on. Choices are: %r' % (platforms,))
    run_opt.add_argument('--config', default=None, help='Specify a Python config file to use when running the app. For iOS and Android, this must be specified in the build step.')
    run_opt.add_argument('args', nargs=argparse.REMAINDER)
    run_opt.set_defaults(func=run)

    test_opt = commands.add_parser('test', help="Run PyEverywhere project")
    test_opt.add_argument('platform', choices=platforms, help='Platform to run the project on. Choices are: %r' % (platforms,))
    test_opt.add_argument('--no-functional', action='store_true', help='Only run unit tests, do not start the GUI and run functional tests.')
    test_opt.set_defaults(func=test)

    up_opt = commands.add_parser('update', help="Update the PyEverywhere dependencies for the project in the current working directory.")
    up_opt.add_argument('platform', choices=platforms, help='Platform to run the project on. Choices are: %r' % (platforms,))
    up_opt.set_defaults(func=update)

    config_text = ""
    for name in config_settings:
        config_text += "    %s: %s" % (name, config_settings[name])
    config_opt = commands.add_parser('set', help="Configure PyEverywhere settings.")
    config_opt.add_argument('name', help='Setting to configure.')
    config_opt.add_argument('value', help='Value for the configuration setting.')
    config_opt.set_defaults(func=set)

    get_opt = commands.add_parser('get', help="View PyEverywhere settings.")
    get_opt.add_argument('name', help='Setting to view. Specify "all" to view all settings.')
    get_opt.set_defaults(func=get)

    args = parser.parse_args()

    if args.verbose:
        global verbose
        verbose = True
        print("Verbose output set.")

    if not args.func in [create, get, set]:
        if not os.path.exists(info_file):
            print "Unable to find project info file at %s. pew cannot continue." % info_file
            sys.exit(1)

        global info_json
        info_json = json.loads(open(info_file, "rb").read())
        create_android_setup_sh(info_json)
    sys.exit(args.func(args))

if __name__ == "__main__":
    main()
